# 28.1-金融系统中的RSA算法（一）

## 背景

随着科技的日新月异，各种各样快捷便利的网站与应用让我们的生活变得越来越简单。十几年前，你能够想到大家竟然能够那么放心的通过网络将钱转给商家，而不用担心自己的钱打水漂么？我们如今之所以能够那么放心的在网上进行各种交易，得益于我们各种技术和加密算法的推陈出新，让我们的交易能够更有保障。今天，我们就来学习一下在金融系统中尤为重要的一个加密算法：`RSA`算法的前世今生，力求把这个算法的前置知识了解的明明白白。



## 对称加密与非对称加密

### 对称加密：凯撒密码

最早的对称加密是应用于战争中传送机要情报，被称为`凯撒密码`。

他的工作原理很简单，就是定义了`偏移量`的概念。假如我们的密码中只有26个英文字母，我们的偏移量为`3`，那么，原本单词`ABC`就会被加密为：`DEF`,这样，如果不知道偏移量的人，即使拿到了这个信息，也是错误的信息。而知道偏移量的人，可以根据约定的偏移量解密出正确的信息。

从上面的描述中，我们不难发现，`对称加密`需要保证加密的人和解密的人知道同样的信息，在上面的示例中，这个信息就是偏移量。

由于加密的对称性，只要我们破译了其中一个字母的对应关系，那么其他所有字母的对应关系也就破译出来了。例如，经研究表明，一封正常的由英文组成的书信当中，出现频次最多的字母通常是`e`,如果你截获的的书信中出现频次最高的字母不是`e`,比如是`j`,那么，大概率`e`对应的就是`j`,这样，我们就可以通过这个字母反推出其他字母的对应关系，从而破译出整个密文。因此，对称加密的安全性在密码学发展日新月异的今天，还是不太够的。在密码学不断发展的历史进程中，可能也会被逐渐被更安全的`非对称加密`所取代。

总结一下：**对称加密对称的是信息传递双方的加解密信息，需要特别保护的也是这个加解密信息。一旦加解密信息泄露，密文就会很容易被破译出来**



### 非对称加密

别名：**公开密钥加密算法**

非对称的是信息传递双方的**加解密信息**需要保护的是**解密信息**，而加密信息则可以公开。

例如，我现在要传递一个不超过3位的数字，加密方在传递给解密方时，直接在原始数字的基础上乘以`91`，然后将结果的后三位发送给解密方。而解密方接受到这个数字之后，在密文的基础上乘以`11`，再取后三位就是是原数据信息了。比如，我要发送`123`出去，那么先将`123 * 91 = 11193`,然后取结果的后三位`193`发送给解密方。而解密方接收到`193`之后，将他乘上11：`193 * 11 = 2123`,再取后三位即为原数字`123`。

上述就是一个比较简单的非对称解密的算法，发送信息的人，只知道怎么加密，但他不知道要怎么解密，就算密码被截获，其他人也很难知道如何解密。因为只有解密人才知道解密方式。

由于相交于`对称加密`需要同时保护加密信息和解密信息而言，`非对称加密`要保护的只有解密信息，更容易保护，也更加安全。比如，我们经常使用`ssh`登录服务器，我可以把公钥上传到服务器上，所有能登录这个服务器的人都可以查看，没关心，因为私钥只在我手上才有，只有我的私钥才可以用我的身份登录服务器。

## RSA算法的实现过程

既然`RSA`算法是非对称加密算法，那么，实现这个算法最关键的就是要生成两把`钥匙`,一把用来加密，一把用来解密。加密的钥匙可以公之于众，但是用于解密的钥匙我们得自己留着。

### 如何造钥匙？

1. 选择两块`上好的铁皮`,即原料

   这两块铁皮就是两个不相等的`素数`,设他们为：`P`，`Q`

2. 做出钥匙的模具

   一个模具用来生产加密钥匙，一个模具用来生产解密钥匙。

   设：`N = P * Q`

   `φ(N) = (P - 1) * (Q - 1)`

   其中`φ`是欧拉函数，我们之前学习[欧几里得算法](./25.1-欧几里得算法.md)时已经学习过，这里就不再赘述，不明白的同学可以点击上面的链接去看一下之前的文章。

3. 随便做一把加密的钥匙，反正都要公之于众，随便就好

   随便选择一个与`φ(N)`互质的数字`e`即可

4. 根据加密钥匙精心设计一把解密钥匙

   `e * d % φ(N) = 1`

   其中，`d`就是我们根据模子做出来的与加密钥匙配对的解密钥匙。

5. 打包加密钥匙和解密钥匙

   - **加密钥匙：**`(e, N)`
   - **解密钥匙：**`(d, N)`

   此时，我们可以把加密钥匙公之于众了，而解密钥匙必须我们自己保留。

加密钥匙也叫做`公钥`，而解密钥匙叫做`私钥`。

### 如何使用这两把钥匙

1. 加密人使用加密钥匙`(e, N)`

   **加密过程：**`M ^ e % N = C`

   其中`M`是明文，而`C`就是加密后的密文

2. 收到密文信息的人使用解密钥匙`(d, N)`

   **解密过程：**`C ^ d % N = M`

### 非对称加密的好处是什么

**被加密的方法和信息都可以随意被窃取，反正你没有解密方法你也解密不了。**

举个很好的例子：我们可以用公钥在我们的web应用中加密数据传输到服务器，只要有开发经验的人估计都知道可以通过浏览器的开发者工具查看源码就可以看到具体的加密方法和公钥，但是，我们并不担心，因为用户输入的信息经过加密后，只有我们服务器上存储的私钥才能对这个加密信息进行解密，其他人就算知道这是RSA加密，知道了公钥，也无济于事。

## RSA算法加解密过程的证明

- **加密过程：**`M ^ e % N = C`
- **解密过程：**`C ^ d % N = M`

我们需要证明，加密出来的密文`C`确实能够通过解密过程还原出`M`，即证明：

`(M^e)^d % N = M`

```bash
(M ^ e)^d % N = M^(e * d) % N

因为：`e * d % φ(N) = 1`
所以上述公司可转换为：
M^(k * φ(N) + 1) % N = M^(k * φ(N)) * M % N
根据欧拉定理，如果M与N互质，那么`M^(k * φ(N)) % N = 1`，上述公式可转换为：
最终左侧公式化简为M，至此，我们证明了上述公式`(M^e)^d % N = M`

```

证明时使用到了`欧拉公式`与`欧拉定理`均在[欧几里得算法](./25.1-欧几里得算法.md)中学习过，我们再此就不再赘述。

## 结语

至此，我们已经初步了解了对称加密与非对称加密，也了解了RSA算法的原理和证明过程，我们之后再来看看，如何实现一个简单的RSA算法。



