## 前言

我们已经学习了红黑树的概念、基本性质、平衡条件、与AVL树的关系，也学习了红黑树的集中失衡情况以及这些失衡情况都要如何进行调整，还通过`Typescript`手写了一个支持插入操作的红黑树结构。那么接下来，我们就通过一些相关的算法题来巩固一下这些知识点吧

## [LeetCode 1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)

### 解题思路

这道题的意思就是让我们在一颗完整的二叉树上砍一刀，使得新生成的两个二叉树的和值的乘积最大。要如何保证乘积最大呢？是不是两个乘数越接近，乘积就越大。那么，我们要先求出整颗二叉树的和，然后取他的中位数。然后拆出来的两颗子树的，他们的各自的和值越接近中位数，最终得出的乘积就会越大

### 代码演示

![1336](https://ydschool-video.nosdn.127.net/16307381440911336.png)

## [LeetCode 971. 翻转二叉树以匹配先序遍历](https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/)

### 解题思路

我们都知道，二叉树的前序遍历结果是`根左右`,那么，如果一个序列要与二叉树的前序遍历结果能够匹配的上的话，除了根节点要能匹配的上之外，根节点的左子树也要能跟序列的下一个节点匹配上，如果不匹配，我们就尝试反转一下左右子树，看看能不能匹配，如果发生了翻转，则将翻转的节点记录下来即可

### 代码演示

![971](https://ydschool-video.nosdn.127.net/1630745274924971.png)

## [LeetCode 117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

### 解题思路

如果这道题没有「你只能使用常量级额外空间 」这个限制的话，那么，我们或许可以用我们之前学过的广度优先搜索`BFS`，但是，有了 额外空间的限制，由于广搜一般要借助队列进行辅助，而队列的大小跟节点正相关，明显占用了非常量级的额外空间。那么，我们要如何通过常量级的额外空间求解呢？

我们可以定义一个额外的方法`_connect`，用来进行每一层遍历串联，并返回下一层串联后的第一个节点。然后我们再不断的循环调用这个方法，直到这个方法返回的节点为空时说明已经到了最后一层了。那么到此，我们也就串联完成了整颗二叉树了。

### 代码演示

![117](https://ydschool-video.nosdn.127.net/1630749166729117.png)

## [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

### 解题思路

这道题对二叉树的考察点不多，但却考察了包括广义表、自动机的一些实现思路。

首先我们可以使用[广义表](https://baike.baidu.com/item/%E5%B9%BF%E4%B9%89%E8%A1%A8/3685109?fr=aladdin)的规则对二叉树进行序列化。

反序列化时，我们采用类似[有限状态自动机](https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E6%9C%BA)的设计思路，设置一个通用的状态变更的“路由”，所有其他操作完成后，最终都会回到这个路由进入下一个状态的演变。

### 代码演示

![449](https://ydschool-video.nosdn.127.net/1630756173145449.png)