## 前言

了解了`二叉排序树`和`AVL树`的基本概念，知道了`前驱节点`和`后继节点`的含义以及对于`AVL树`的`左旋`和`右旋`操作有了基本的认知，接下来就通过一些相关的算法题深入巩固一下这些知识点。

## [面试题 04.06. 后继者](https://leetcode-cn.com/problems/successor-lcci/)

### 解题思路

题目说明了该二叉树时一个二叉排序树，那么，我们可以在中序遍历的过程中，访问到每一个节点，而当前节点的后继节点，其实就是在中序遍历的有序结果中的下一个节点，因此，我们可以记录遍历到的所有节点的上一个节点，然后在中序遍历的过程中，一旦上一个节点与目标值p匹配，则说明当前的节点就是我们要找的后继节点了。当然，这边还需要考虑后继节点在左子树和右子树的情况。

### 代码演示

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @return {TreeNode}
 */
//  用于记录当前节点上一个节点
let pre = null;
function inorder(root, p){
    // 在中序遍历的过程中，我们可以拿到这个树的每个节点的值
    // 若根节点为空，依据题意，直接返回null
    if(!root) return null;
    // 如果在左子树中找到了目标值，则直接返回
    const nodeL = inorder(root.left, p);
    if(nodeL) return nodeL;
    // 如果上一个节点与p相等，说明当前节点就是后继节点，返回当前节点
    if(pre === p) return root;
    // 更新pre的值
    pre = root;
    // 如果在右子树中找到目标值，也返回
    const nodeR = inorder(root.right, p);
    if(nodeR) return nodeR;
    // 左右子树都找不到则返回null
    return null;
}
var inorderSuccessor = function(root, p) {
    pre = null;
    return inorder(root, p);
};
```

## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

### 解题思路

这题就是赤裸裸的二叉搜索树删除节点并维护二叉搜索树特性的问题，思路跟数据结构基础篇的代码实现中的删除代码一样，这里就不再赘述，直接上代码。（注意，由于删除度为2的节点可以找前驱，也可以找后继，因此答案不唯一，但只要将目标key删除并维护二叉搜索树的性质即可）。

### 代码演示

```typescript
/*
 * @lc app=leetcode.cn id=450 lang=typescript
 *
 * [450] 删除二叉搜索树中的节点
 *
 * https://leetcode-cn.com/problems/delete-node-in-a-bst/description/
 *
 * algorithms
 * Medium (48.06%)
 * Likes:    496
 * Dislikes: 0
 * Total Accepted:    53.5K
 * Total Submissions: 110.9K
 * Testcase Example:  '[5,3,6,2,4,null,7]\n3'
 *
 * 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key
 * 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
 * 
 * 一般来说，删除节点可分为两个步骤：
 * 
 * 
 * 首先找到需要删除的节点；
 * 如果找到了，删除它。
 * 
 * 
 * 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。
 * 
 * 示例:
 * 
 * 
 * root = [5,3,6,2,4,null,7]
 * key = 3
 * 
 * ⁠   5
 * ⁠  / \
 * ⁠ 3   6
 * ⁠/ \   \
 * 2   4   7
 * 
 * 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
 * 
 * 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
 * 
 * ⁠   5
 * ⁠  / \
 * ⁠ 4   6
 * ⁠/     \
 * 2       7
 * 
 * 另一个正确答案是 [5,2,6,null,4,null,7]。
 * 
 * ⁠   5
 * ⁠  / \
 * ⁠ 2   6
 * ⁠  \   \
 * ⁠   4   7
 * 
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function predeccessor(root: TreeNode): TreeNode {
    let tmp = root.left;
    while(tmp.right) tmp = tmp.right;
    return tmp;
}
function deleteNode(root: TreeNode | null, key: number): TreeNode | null {
    if(!root) return root;
    if(key > root.val) root.right = deleteNode(root.right, key);
    else if(key < root.val) root.left = deleteNode(root.left, key);
    else {
        if(!root.left || !root.right) {
            const tmp = root.left ? root.left : root.right;
            root = null;
            return tmp;
        } else {
            const tmp = predeccessor(root);
            root.val = tmp.val;
            root.left = deleteNode(root.left, tmp.val);
        }
    }
    return root;
};
// @lc code=end


```

## [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)

### 解题思路

要将一颗二叉排序树变得尽可能平衡，其实可以转换成着这样的一个问题来看：由于二叉排序树的中序遍历结果是一个有序序列，我们需要每次都尽可能的挑中间的节点作为根节点就可以保证二叉排序树尽可能平衡。

首先，使用中序遍历将每一个节点放入到一个数组中。然后，我们可以使用二分法，每次调中间的节点作为根节点，然后再递归的挑选左子树和右子树即可

```typescript
/*
 * @lc app=leetcode.cn id=1382 lang=typescript
 *
 * [1382] 将二叉搜索树变平衡
 *
 * https://leetcode-cn.com/problems/balance-a-binary-search-tree/description/
 *
 * algorithms
 * Medium (68.83%)
 * Likes:    73
 * Dislikes: 0
 * Total Accepted:    10.3K
 * Total Submissions: 15K
 * Testcase Example:  '[1,null,2,null,3,null,4]'
 *
 * 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。
 * 
 * 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。
 * 
 * 如果有多种构造方法，请你返回任意一种。
 * 
 * 
 * 
 * 示例：
 * 
 * 
 * 
 * 输入：root = [1,null,2,null,3,null,4,null,null]
 * 输出：[2,1,3,null,null,null,4]
 * 解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 树节点的数目在 1 到 10^4 之间。
 * 树节点的值互不相同，且在 1 到 10^5 之间。
 * 
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function inorder(root: TreeNode|null, nodes: TreeNode[]){
    if(!root) return;
    inorder(root.left, nodes);
    nodes.push(root);
    inorder(root.right, nodes);
}

function buildTree(nodes: TreeNode[], l: number, r: number): TreeNode|null {
    if(l > r) return null;
    const mid = (l + r) >> 1;
    const root = nodes[mid];
    root.left = buildTree(nodes, l, mid - 1);
    root.right = buildTree(nodes, mid + 1, r);
    return root;
}

function balanceBST(root: TreeNode | null): TreeNode | null {
    // 要将一颗二叉排序树变得尽可能平衡，其实可以转换成着这样的一个问题来看：
    // 由于二叉排序树的中序遍历结果是一个有序序列，我们只需要每次都尽可能的挑中间的节点
    // 作为根节点就可以保证二叉排序树尽可能平衡
    // 使用中序遍历将每一个节点放入到一个数组中
    const nodes: TreeNode[] = [];
    inorder(root, nodes);

    // 使用二分法每次挑选中间的节点作为子树
    return buildTree(nodes, 0, nodes.length-1);
};
// @lc code=end


```

## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

### 解题思路

这题思路跟上一题是一模一样的，还不用我们自己中序遍历获取节点数组，他直接就给我么一个有序的数字数组，我们只需要不断二分找寻中间值作为根节点，然后递归创建左右子树即可

### 代码演示

```typescript
/*
 * @lc app=leetcode.cn id=108 lang=typescript
 *
 * [108] 将有序数组转换为二叉搜索树
 *
 * https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/
 *
 * algorithms
 * Easy (75.77%)
 * Likes:    813
 * Dislikes: 0
 * Total Accepted:    180K
 * Total Submissions: 237.3K
 * Testcase Example:  '[-10,-3,0,5,9]'
 *
 * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
 * 
 * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
 * 
 * 
 * 
 * 示例 1：
 * 
 * 
 * 输入：nums = [-10,-3,0,5,9]
 * 输出：[0,-3,9,-10,null,5]
 * 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
 * 
 * 
 * 
 * 示例 2：
 * 
 * 
 * 输入：nums = [1,3]
 * 输出：[3,1]
 * 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 1 
 * -10^4 
 * nums 按 严格递增 顺序排列
 * 
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function buildTree(nums: number[], l: number, r: number): TreeNode|null {
    if(l > r) return null;
    const mid = (l + r) >> 1;
    const root = new TreeNode(nums[mid]);
    root.left = buildTree(nums, l, mid - 1);
    root.right = buildTree(nums, mid+1, r);
    return root;
}

function sortedArrayToBST(nums: number[]): TreeNode | null {
    return buildTree(nums, 0, nums.length-1);
};
// @lc code=end


```

## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

### 解题思路

我们要学会利用结构化思维思考问题，如果一棵树是二叉搜索树，那么他的中序遍历结果就一定是一个升序的序列，那么我们就可以在中序遍历的过程中，访问每一个值，看一下他是不是升序的。这其实跟我们判断一个的数组是否是升序的一样的，可以看成for循环遍历每一个值。

### 代码演示

```typescript
/*
 * @lc app=leetcode.cn id=98 lang=typescript
 *
 * [98] 验证二叉搜索树
 *
 * https://leetcode-cn.com/problems/validate-binary-search-tree/description/
 *
 * algorithms
 * Medium (34.66%)
 * Likes:    1167
 * Dislikes: 0
 * Total Accepted:    319.6K
 * Total Submissions: 919.6K
 * Testcase Example:  '[2,1,3]'
 *
 * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
 * 
 * 假设一个二叉搜索树具有如下特征：
 * 
 * 
 * 节点的左子树只包含小于当前节点的数。
 * 节点的右子树只包含大于当前节点的数。
 * 所有左子树和右子树自身必须也是二叉搜索树。
 * 
 * 
 * 示例 1:
 * 
 * 输入:
 * ⁠   2
 * ⁠  / \
 * ⁠ 1   3
 * 输出: true
 * 
 * 
 * 示例 2:
 * 
 * 输入:
 * ⁠   5
 * ⁠  / \
 * ⁠ 1   4
 * / \
 * 3   6
 * 输出: false
 * 解释: 输入为: [5,1,4,null,null,3,6]。
 * 根节点的值为 5 ，但是其右子节点值为 4 。
 * 
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
let pre = Number.MIN_SAFE_INTEGER;
function inorder(root: TreeNode | null){
    if(!root) return true;
    if(!inorder(root.left)) return false;
    if(pre !== Number.MIN_SAFE_INTEGER && root.val <= pre) {
        return false;
    }
    pre = root.val;
    if(!inorder(root.right)) return false;
    return true;
}
function isValidBST(root: TreeNode | null): boolean {
    pre = Number.MIN_SAFE_INTEGER;
    
    return inorder(root);
};
// @lc code=end


```

## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

### 解题思路

这道题依然是利用了二叉搜索树中序遍历时一个有序序列的特性，利用结构化思维，在中序遍历过程中，不断累加当前数字出现的次数，并与之前记录的最大出现次数做对比看当前数字是否是众数。

- 如果当前数字出现的次数与之前的最大次数相同，则说明当前数字是众数，加入到结果中。

- 如果当前数字出现的次数大于之前记录的最大次数，则说明我们之前都白费功夫了，之前记录的都不是真正的众数，我们需要重新更新最大次数，并清空之前加入到结果数组中的“伪众数”，然后将当前数字加入到结果数组中。

- 而如果当前次数小于之前最大的次数，那我们可以忽略不用处理，因为有可能后面还会有相同的次数出现，此时处理没有意义。

### 代码演示

```typescript
/*
 * @lc app=leetcode.cn id=501 lang=typescript
 *
 * [501] 二叉搜索树中的众数
 *
 * https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/
 *
 * algorithms
 * Easy (50.89%)
 * Likes:    332
 * Dislikes: 0
 * Total Accepted:    61.2K
 * Total Submissions: 119.9K
 * Testcase Example:  '[1,null,2,2]'
 *
 * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
 * 
 * 假定 BST 有如下定义：
 * 
 * 
 * 结点左子树中所含结点的值小于等于当前结点的值
 * 结点右子树中所含结点的值大于等于当前结点的值
 * 左子树和右子树都是二叉搜索树
 * 
 * 
 * 例如：
 * 给定 BST [1,null,2,2],
 * 
 * ⁠  1
 * ⁠   \
 * ⁠    2
 * ⁠   /
 * ⁠  2
 * 
 * 
 * 返回[2].
 * 
 * 提示：如果众数超过1个，不需考虑输出顺序
 * 
 * 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
let maxCount = 0;
let curCount = 0;
let pre;
function inorder(root: TreeNode | null, ret: number[]) {
    if(!root) return;
    inorder(root.left, ret);
    // 由于二叉搜索树的中序遍历结果是升序的，因此，相同的数肯定是紧挨着出现的
    // 如果如果上一个节点的值等于当前节点的值，则累加出现次数
    if(pre.val === root.val) {
        curCount+=1;
    } else {// 否则说明这个数时第一次出现，设置次数为一，并更新上一个节点为root
        curCount = 1;
        pre = root;
    }
    // 如果当前累计次数等于最大次数，说明我们又找到了一个众数，将这个数加入到结果数组中
    if(curCount === maxCount) {
        ret.push(root.val);
    } else if(curCount > maxCount) {
        // 如果当前累计次数大于之前记录的最大次数，则说明之前记录的都不是真正的众数，更新最大次数、
        // 清空原结果数组，再重新将新的众数压入数组中
        maxCount = curCount;
        ret.length = 0;
        ret.push(root.val);
    }
    
    inorder(root.right, ret);
}
function findMode(root: TreeNode | null): number[] {
    maxCount = curCount = 0;
    pre = root;
    const ret: number[] = [];
    inorder(root, ret);
    return ret;

};
// @lc code=end


```

## [面试题 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/)

### 解题思路

依然利用结构化思维，在中序遍历过程中，将每一个节点更新成链表节点

### 代码演示

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function inorder(root: TreeNode | null, info: {pre: TreeNode|null,head: TreeNode|null}){
    if(!root) return;
    inorder(root.left, info);
    // 没有上一个节点，说明当前节点是头结点
    if(info.pre === null) {
        info.head = root;
    } else {
        // 将上一个节点的下一个节点指向当前节点
        info.pre.right = root;
    }
    // 将当前节点的左节点置空
    root.left = null;
    // 更新上一个节点
    info.pre = root;
    
    inorder(root.right, info);
}
function convertBiNode(root: TreeNode | null): TreeNode | null {
    // 用于记录上一个节点和链表头结点信息
    let info = {
        pre: null,
        head: null
    };
    inorder(root, info);
    return info.head;
};
```

## [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

### 解题思路

我们假设输入数组就是一颗二叉搜索树的后续遍历结果，那么，既然他是一颗合法的二叉搜索树，那他的中序遍历结果必定是升序的，我们就可以对这棵树的中序遍历的过程中，验证他是否是升序的，如果是，则我们的假设是正确的，输入数组确实是二叉搜索树的后续遍历结果，否则，说明假设不成立。

在解题的过程中，需要掌握如何在一个后续遍历结果中准确找到二叉树的左子树、右子树和根节点，然后进行中序遍历。

在这里，我们无需使用实际的树形结构，根据二叉树的后序遍历的特性，我们知道他的结果是：左子树、右子树、根节点的顺序的，而又因为我们假设这个二叉树是二叉搜索树，所以，所有左子树的值都要小于根节点，右子树的值都要大于根节点，那么，我们要找到左子树、右子树、和根节点就很简单了：

- 根节点：序列最后一个节点就是根节点
- 左子树：从序列左侧左侧第一个大于根节点的节点的前一个节点为止就是左子树
- 右子树：从第一个大于根节点的节点开始到倒数第二个节点是右子树

确定了三个关键的区间，我们就可以对这个区间进行中序遍历，并在遍历的过程中校验其是否升序了。

### 代码演示

```typescript
let pre;

function inorder(postorder: number[], l: number, r: number): boolean {
    if(l > r) return true;
    // 现在后续遍历序列中找到左右子树的区间范围，由于后续遍历是：左 右 根
    let idx = 0;
    // 如果idx所对应节点的值比根节点小，则右移，直到遇到第一个比根节点大的值为止，idx就停留到了右子树根节点的位置
    while(postorder[idx] < postorder[r]) ++idx;
    if(!inorder(postorder, l, idx - 1)) return false;

    // 如果pre不是-1说明不是第一个节点,并且上一个值如果大于根节点的值，说明中序遍历结果不是一个升序的序列
    // 也就说明输入的后续遍历结果不是一个二叉搜索树
    if(pre !== -1 && postorder[pre] > postorder[r]) return false;
    // 将上一个节点更新为当前根节点
    pre = r;

    if(!inorder(postorder, idx, r - 1)) return false;
    return true;
}

function verifyPostorder(postorder: number[]): boolean {
    // 代表当前节点上一个节点的索引
    pre = -1;
    return inorder(postorder, 0, postorder.length-1);
};
```

## [1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

### 解题思路

这道题本质上解题思路与上一题差不多，只是从后续遍历变成了前序遍历而已。

### 代码演示

```typescript
/*
 * @lc app=leetcode.cn id=1008 lang=typescript
 *
 * [1008] 前序遍历构造二叉搜索树
 *
 * https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/
 *
 * algorithms
 * Medium (72.81%)
 * Likes:    162
 * Dislikes: 0
 * Total Accepted:    15.9K
 * Total Submissions: 21.9K
 * Testcase Example:  '[8,5,1,7,10,12]'
 *
 * 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
 * 
 * (回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而
 * node.right 的任何后代，值总 > node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历
 * node.right。）
 * 
 * 题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
 * 
 * 
 * 
 * 示例：
 * 
 * 输入：[8,5,1,7,10,12]
 * 输出：[8,5,10,1,7,null,12]
 * 
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 1 <= preorder.length <= 100
 * 1 <= preorder[i] <= 10^8
 * preorder 中的值互不相同
 * 
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function buildTree(nums: number[], l: number, r: number): TreeNode|null {
    // 由于输入的数组时二叉搜索树的前序遍历结果，因此他应该是：根节点、左子树、右子树的结构
    if(l > r) return null;
    // 查找右子树的第一个节点，方便区分出左子树区间和右子树区间，
    let idx = l + 1;
    // 如果节点值小于根节点，那么一定是属于左子树，继续往后走，直到找到第一个大于根节点的值，就是右子树的第一个节点
    while(idx <= r && nums[idx] < nums[l]) ++idx;
    // 首先创建根节点
    const root = new TreeNode(nums[l]);
    // 递归创建左子树
    root.left = buildTree(nums, l + 1, idx - 1);
    // 递归创建右子树
    root.right = buildTree(nums, idx, r);
    return root;
}
function bstFromPreorder(preorder: number[]): TreeNode | null {
    return buildTree(preorder, 0, preorder.length - 1);
};
// @lc code=end


```

## [面试题 04.09. 二叉搜索树序列](https://leetcode-cn.com/problems/bst-sequences-lcci/)

### 解题思路

这道题要我们找出所有可以生成目标二叉搜索树的数组排列，那么，我们先从最简单的情况开始分析：

```bash
# 例题中的二叉树输入
           2
        /     \
       1       3
# 以上二叉树有两种可能性，分别是：
[2,1,3]
[2,3,1]
# 从这里我们可以看出，在这个最简单的二叉排序树中，其实我们只要确保根节点2是第一个被插入的，剩下两个节点即他的左右子树的插入顺序其实我们并不需要关心，因为这是一颗二叉搜索树，他们总能找到自己该待的地方。

# 接下来我们在看一个稍微复杂点的示例
                     5
                  /     \
                4        7
              /   \    /   \
             1     3  6     9
# 对于以上二叉搜索树，又有几种组合呢？
# 按照上面分析的思路，我们可以先确定下来，节点5必须要首先插入，因此先把节点5摘出来不去看，我们分别来看看左右子树都有哪些排列的可能
# 对于左子树来说，我们要确保能生成以4为根节点的二叉排序树，就要确保4节点先插入，那么，左子树的可能性有：
[4,1,3]
[4,3,1]
# 同理，右子树也是类似
[7,6,9]
[7,9,6]
# 以上就是左右子树各自组合的可能性，那么整棵树组成的可能性就只有这四种吗？答案是否定的。
# 因为我们说了，只要确保根节点先插入，子节点顺序无所谓，那么我们可以在保持节点插入先后顺序相对不变的前提下左右子树的节点分别穿插着插入，如：
[4,7,1,6,3,9]
[4,7,1,7,6,9]
[4,1,7,6,3,9]
...
# 例如上面的示例，他们都保证了左右子树插入节点的顺序相对不变，但并非连续性的插入
# 因此，我们需要枚举每一种排列组合的情况，将所有可能的情况都尝试一遍

```



### 代码演示

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function mergeSequences(
    lArr: number[], // 左子树可能的序列集合
    lIdx: number, // 已经从左子树中挑选了几个元素参与最终的排列组合
    rArr: number[], // 右子树可能的序列集合
    rIdx: number, // 已经从右子树中挑选了几个元素参与最终的排列组合
    buff: number[], // 缓冲区，用于临时存储一组排列组合
    res: number[][]// 结果数组
) {
    // 当我们已经将左右子树序列集合中的所有数都尝试组合过一遍之后，当前缓冲区当中存放的就是我们要的答案
    if(lIdx === lArr.length && rIdx === rArr.length) {
        // 注意：由于数组时引用，如果直接使用res.push(buff)的话，由于数组的引用相同，会与后续的操作发生冲突，导致无法得到正确的解
        // 因此我们应该拷贝出一份数据出来放到结果数组中
        res.push([...buff]);
        return;
    }
    // 如果左子树序列集合还有元素没有被挑选，
    if(lIdx < lArr.length) {
        // 则将第一个没被挑选的元素加入到缓冲区中
        buff.push(lArr[lIdx]);
        // 然后再此基础上尝试继续匹配后续的元素（此时，左子树序列集合中已经多了一个被使用的元素，因此lIdx要加1）
        mergeSequences(lArr, lIdx + 1, rArr, rIdx, buff, res);
        // 在以当前的数字为起点继续匹配完成后，我们需要回溯，把当前元素从缓冲区中移除掉，消除这一轮求解的影响，方便下一轮的查找
        buff.pop();
    }
    // 同理在右子树序列集合中挑选元素
    if(rIdx < rArr.length) {
        buff.push(rArr[rIdx]);
        mergeSequences(lArr, lIdx, rArr, rIdx + 1, buff, res);
        buff.pop();
    }
}
function BSTSequences(root: TreeNode | null): number[][] {
    let res: number[][] = [];
    // 如果树为空，则返回[[]]
    if(!root) {
        res.push([]);
        return res;
    }
    // 先递归查找左右子树可能组合的序列
    const lArr = BSTSequences(root.left);
    const rArr = BSTSequences(root.right);

    // 然后将他们挨个排列组合
    for(const l of lArr) {
        for(const r of rArr) {
            // 缓冲区，用于存放可能的某一组解
            const buff: number[] = [];
            // 根节点可以直接压入到缓冲区中，因为根节点必定要首先插入
            buff.push(root.val);
            // 将左右子树可能组合的序列按照排列组合的方式合并成一组组答案
            mergeSequences(l, 0, r, 0, buff, res);
        }
    }
    return res;
};
```

