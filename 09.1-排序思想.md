## 计数排序基础知识与原理

当我们待排序的序列中只有有限种类的数，如只有1，2，3三个数字时，适合使用计数排序，因为只有这么几种情况，我们只需要把每个数字出现的次数统计出来，然后按照顺序依次输出每个数字统计个数的数即可。如：

原数组：[3,2,2,3,1,1,2]

计数：1出现了2次，2出现了3次，3出现了两次

排序: 先输出两个1，在输出3个2，最后输出2个三

结果: [1,1,2,2,2,3,3]

### 应用场景

综上所述：**计数排序适用于简单的单值排序问题，排序问题中，数据的值域很有限**

例如：我现在要统计全国所有人的年龄，并且按照年龄进行排序，这种情况下，因为我们的值域即年龄是很有限的，最多也就是0~150左右，这时，我们就可以使用这种计数排序的方式进行排序。

**PS：所谓的单值排序，是指我们用于排序的值只有一个，相较于我们经常用的多值排序，是根据我们某个对象下的某个字段进行排序，如根据对象的id进行排序**

## 基数排序基础知识与原理

基数排序的场景比较特殊，要进行基数排序要满足以下两个条件：

1. 每个数字都是2/3/4...位数(也就是说所有数字的位数是一样的，当数字位数不同时，我们就要按照数组中位数最大的那个数把其他数补位，如：12和345，要对12进行补位得：012和345,在进行操作)

**特性：基数排序可以保证数据的稳定性，其时间复杂度可以达到O(N)。（所谓数据稳定性就是保证原始数据的相对位置不变，即使两个数字都是1，但之前第一个1排在前面，第二个1排在后面，那么，排完序之后，依然能保证这样的相对顺序）**

例如：[21,31,23,22,33,13,12,11]

如上面的数组，进行基数排序的话，我们首先要对`个位`上的数进行处理，然后再对`十位`上的数进行处理

- 对个位进行处理

  - 统计个位中每种数字出现的次数
    - `1`出现了`3`次
    - `2`出现了`2`次
    - `3`出现了`3`次
  - 然后根据统计的次数求出每个次数的前缀和(前缀和数组中的每一个元素，代表每个数字存放区域的尾索引+1)
    - `1`的前缀和：`3`,`1`的存放区域尾部索引为`2`，即索引为0~2的地方都放`1`
    - `2`的前缀和：`5`,`2`的存放区域尾部索引为`4`，即索引为3~4的地方都放`2`
    - `3`的前缀和：`8`,`3`的存放区域尾部索引为`7`，即索引为5~7的地方都放`3`
  - 求出前缀和之后，我们就能够确定个位树的排序
    - 前三个数字(索引：0,1,2)放的应该是`1`
    - 索引3,4放的数字应该是`2`
    - 索引5,6,7应该放`3`
    - 然后按照每次数字所在的区间，将原数组从右向左扫描一遍，将个位数为指定值的树从后往前放入到他对应的区间中。得出根据个位数的排序：[21,31,11,22,12,23,33,13]

- 对十位进行处理

  - 统计十位数中每个数字出现的次数
    - `1`出现了`3`次
    - `2`出现了`3`次
    - `3`出现了`2`次
  - 同上求出前缀和
    - `1`的前缀和：`3`,`1`的存放区域尾部索引为`2`，即索引为0~2的地方都放`1`
    - `2`的前缀和：`6`,`2`的存放区域尾部索引为`5`，即索引为3~5的地方都放`2`
    - `3`的前缀和：`8`,`3`的存放区域尾部索引为`7`，即索引为6~7的地方都放`3`
    - 然后按照每次数字所在的区间，将上一轮经过个位数排序的数组从右向左扫描一遍，将十位数为指定值的树从后往前放入到他对应的区间中。得出根据十位数排序后的结果:[11,12,13,21,22,23,31,33]

   经过上面的操作，我们就已经将这个数组排序了。

### 代码演示

```javascript
function radixSort(arr, len = arr.length) {
    // 整形数据总共有32个数据位，我们将其拆分成低16位和高16位分别用来模拟个位和十位的运算
    const halfBit32 = Math.pow(2, 16);
    const partBit32 = halfBit32 / 2;
    // 获取低16位数字的工具函数，只要将目标数字与16进制数0xffff进行按位与操作就可以得到低16位数了
    const getLow16BitNum = num => (num & 0xffff);
    // 同理，定义获取高16位数字的方法
    const __getHeigh16BitNum = num => ((num & 0xffff0000) >> 16);
    // 兼容负数的情况
    const getHeigh16BitNum = num => __getHeigh16BitNum(num) > (partBit32 - 1) ? (__getHeigh16BitNum(num) - partBit32) : (__getHeigh16BitNum(num) + partBit32);

    let count = new Array(halfBit32);
    let temp = [];
    count.fill(0);

    // 循环数组，计算每个数出现的数量暂存在count数组中
    for (let i = 0; i < len; i++) count[getLow16BitNum(arr[i])] += 1;
    // 求前缀和
    for (let i = 1; i < halfBit32; i++) count[i] += count[i - 1];
    // 前缀和中的每一项就是我们存放每个数字索引加1，因此，我们借助前缀和数组将原数组按照第16位的顺序放入到临时数组中
	for (let i=len-1;i>=0;--i) temp[--count[getLow16BitNum(arr[i])]] = arr[i];


	// 低16位处理完后，将count重新初始化
	count.fill(0);
	// 上面已经将低16位的数排好序放入temp数组了，接下来就要对这个temp数进行高16位数排序
	// 首先，依然是计算每个数的数量
	for(let i=0;i<len;i++) count[getHeigh16BitNum(temp[i])] += 1;
	// 然后继续求前缀和
  for (let i = 1; i < halfBit32; i++) count[i] += count[i - 1];
  // 将数组排序后重新放回arr中完成排序
	for(let i=len-1;i>=0;--i) arr[--count[getHeigh16BitNum(temp[i])]] = temp[i];

}

// 生成指定长度的随机数数组
function getRandomNum(len) {
	let res = [];
	while(--len) {
		res.push((Math.random()>0.5?-1:1) * Math.floor(Math.random()*999999));
	}
	return res;
}

let arr = getRandomNum(100);
console.log('原数组：\n', arr.join('\t'));
radixSort(arr);
console.log('新数组：\n', arr.join('\t'));
```



## 拓扑排序基础知识与原理

是一个`图算法`,由于图的含义极其广泛，因此应用非常广泛。`拓扑排序`就是求出一张图的其中一种`拓扑序`。对于一张`图`而言，`拓扑序`是不唯一的，可能有很多种，一般我们只要求出其中一种即可。拓扑排序我们一般会借助`队列`辅助完成排序。当某一个节点没有任何前置节点，即入度为0时，就可以把这个节点放入队列中，然后依次弹出队列就是我们要求的其中一组`拓扑序`了。

我们工作和生活中很多场景都可以转换成图，然后通过拓扑排序的方式简化处理流程。例如：谣言流传网络、朋友圈分享网络、上下级关系、课程表等等。这些问题咋一看上去及其复杂，但如果将其转换成图，问题就简单很多了。

```bash
# 线面是一个传谣者网络的示意图，右下图可以看出，谣言先由传谣者1和传谣者2传递给了传谣者3，而传谣者3听到谣言后有把谣言传递给了传谣者4和传谣者6，传谣者4听到谣言之后把谣言传给了传谣者5。我们对这个图进行拓扑排序的其中一个结果是：传谣者1->传谣者2->传谣者3->传谣者6->传谣者4->传谣者5。其中，传谣者1是一级传播者，而3是二级传播者，4是三级传播者，而5和6分别是听信谣言但未传播者。这样，我们就把显示生活中的复杂问题在计算机中表现了出来，有了这个传播网络，网警就可以更加有效地预防和控制谣言的传播了。
   传谣者1                       传谣者5
       \                         /
         \                     /
           \                 /
          传谣者3----------传谣者4
          /    \
        /        \
      /            \
传谣者2            传谣者6
```

